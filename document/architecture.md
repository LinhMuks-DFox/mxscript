# MxScript Architecture Specification

## Version

| Item    | Value      |
| ------- | ---------- |
| Version | 1.0.0      |
| Status  | **Draft**  |
| Updated | 2025-07-03 |

---

## 1. Guiding Principles

1.  **Layered & Modular Architecture**: The compiler is organized into distinct layers (frontend, middleend, backend) that communicate through well-defined data structures (Tokens, AST, LLVM IR). This promotes separation of concerns.
2.  **Object-Oriented Runtime**: The C++ runtime (`runtime/`) is built on a pure object-oriented model. Every value in the language is a reference to a heap-allocated object inheriting from a common `MXObject` base class.
3.  **VTable-Based Dispatch**: All core operations (arithmetic, comparison, etc.) are dispatched dynamically using a virtual table (VTable). This avoids centralized `switch` statements and allows for clean, extensible type design.
4.  **Explicit ABI Contract**: The `ffi_map.json` file is the single source of truth for the interface between the compiler frontend and the C++ runtime.

---

## 2. Compilation Pipeline

The process of transforming MxScript source code into executable code follows a multi-stage pipeline, orchestrated by the `src/driver`.

### **2.1. Frontend (`src/frontend`)**

The frontend is responsible for parsing the source text into an intermediate representation that the rest of the compiler can understand.

* **Component**: `src/frontend/tokenizer.py`
    * **Input**: Raw MxScript source code (`.mxs` files).
    * **Process**: Performs **Lexical Analysis**. It scans the source text and converts it into a flat stream of `Token` objects (e.g., `NUMBER`, `IDENTIFIER`, `PLUS`).
    * **Output**: A list of `Token` objects.

* **Component**: `src/frontend/parser.py`, `syntax/syntax.ebnf`
    * **Input**: The stream of `Token` objects.
    * **Process**: Performs **Syntactic Analysis**. It consumes the token stream according to the grammar defined in `syntax.ebnf` and builds a hierarchical representation of the code's structure.
    * **Output**: An **Abstract Syntax Tree (AST)**, where each node represents a construct in the language (e.g., `BinaryExpr`, `FunctionDecl`).

### **2.2. Semantic Analysis (`src/semantic_analyzer`)**

This stage validates the AST for logical correctness, going beyond what syntax parsing can do.

* **Component**: `src/semantic_analyzer/analyzer.py` (example path)
    * **Input**: The raw AST from the parser.
    * **Process**:
        1.  **Symbol Table Management**: Builds and maintains scoped symbol tables to track variables, functions, and types.
        2.  **Type Checking**: Traverses the AST to verify that operations are being performed on compatible types (e.g., preventing `"hello" * "world"`). Annotates AST nodes with type information.
        3.  **ARC Analysis**: Determines where `retain` and `release` calls for Automatic Reference Counting need to be inserted.
    * **Output**: An annotated and validated AST.

### **2.3. Middle End (`src/middleend`)**

This layer acts as a bridge between the frontend and the backend, providing opportunities for high-level, target-independent optimizations.

* **Component**: `src/middleend/optimizer.py` (example path)
    * **Input**: The validated AST.
    * **Process**: (Future work) This is where optimizations like constant folding, dead code elimination, or transformations on a High-Level IR (HIR) would occur before generating LLVM IR.
    * **Output**: An optimized AST or HIR.

### **2.4. Backend (`src/backend`)**

The backend is responsible for converting the high-level AST into low-level, machine-executable code using the LLVM framework.

* **Component**: `src/backend/codegen.py`
    * **Input**: The (potentially optimized) AST.
    * **Process**: Traverses the AST using the **Visitor Pattern** (`visit_...` methods). For each AST node, it emits corresponding LLVM IR instructions. **Crucially, all calls to C++ runtime functions are generated by consulting the ABI contract.**
    * **Output**: LLVM Intermediate Representation (IR) as text.

* **Component**: `src/backend/llir.py`, `src/backend/abi_manager.py`
    * **Input**: LLVM IR text.
    * **Process**:
        1.  The `abi_manager.py` loads and provides an interface to `ffi_map.json`.
        2.  `llir.py` uses the `llvmlite` library to parse the textual LLVM IR, link it with the compiled C++ runtime (`libruntime.so`), and prepare it for execution via the LLVM JIT engine.
    * **Output**: An executable in-memory module.

---


## 3. Runtime Environment (runtime/)

The C++ runtime provides the essential services that MxScript programs need to execute.

### 3.1. Core Object Model

* MXObject (runtime/include/object.h): This is the polymorphic base class for all objects in the language.

* const MXTypeInfo* type_info: A pointer to a static struct containing Runtime Type Information (RTTI).

* virtual ~MXObject() = default;: A virtual destructor to ensure correct cleanup of derived objects.

* virtual auto op_add(...) -> MXObject*: A virtual function for the + operation. The base implementation returns a "TypeError". All standard operations (op_sub, op_eq, op_getitem, etc.) are declared as virtual functions in this base class.

* Concrete Classes (MXInteger, MXString, etc.):

* Each concrete type inherits from MXObject.

* It overrides the virtual functions for the operations it supports (e.g., MXInteger overrides op_add).

* Its constructor sets the type_info pointer to its unique, static MXTypeInfo instance.

### 3.2. Runtime Type Information (RTTI)

* MXTypeInfo (runtime/include/typeinfo.h): This is a simple, non-polymorphic struct responsible for managing type identity and inheritance.

* const char* name: The public name of the type (e.g., "Integer").

* const MXTypeInfo* parent: A pointer to the parent type's MXTypeInfo struct. This forms a linked list that represents the class hierarchy, enabling runtime isinstance checks.

### 3.3. Operation Dispatch

* VTable (Implicit): The VTable mechanism is now managed entirely by the C++ compiler. Declaring functions as virtual in MXObject automatically creates a VTable for each class, which is used for efficient dynamic dispatch.

* Top-Level C API (runtime/src/dispatch.cpp):

* The runtime still exposes simple, extern "C" functions to the compiler via ffi_map.json (e.g., mxs_op_add).

* The implementation of these functions is now a direct virtual call, delegating the work to the object itself.

* Example: return left->op_add(*right);.



---
## 4. Execution and Testing

* **Driver (`main.py`, `src/driver`)**: Orchestrates the entire pipeline, passing the output of one stage to the input of the next.
* **Tests (`tests/`)**: Each component of the pipeline has corresponding unit tests to ensure its correctness and prevent regressions.
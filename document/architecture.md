# MxScript Architecture Specification

## Version

| Item    | Value      |
| ------- | ---------- |
| Version | 1.0.0      |
| Status  | **Draft**  |
| Updated | 2025-07-03 |

---

## 1. Guiding Principles

1.  **Layered & Modular Architecture**: The compiler is organized into distinct layers (frontend, middleend, backend) that communicate through well-defined data structures (Tokens, AST, LLVM IR). This promotes separation of concerns.
2.  **Object-Oriented Runtime**: The C++ runtime (`runtime/`) is built on a pure object-oriented model. Every value in the language is a reference to a heap-allocated object inheriting from a common `MXObject` base class.
3.  **VTable-Based Dispatch**: All core operations (arithmetic, comparison, etc.) are dispatched dynamically using a virtual table (VTable). This avoids centralized `switch` statements and allows for clean, extensible type design.
4.  **Explicit ABI Contract**: The `ffi_map.json` file is the single source of truth for the interface between the compiler frontend and the C++ runtime.

---

## 2. Compilation Pipeline

The process of transforming MxScript source code into executable code follows a multi-stage pipeline, orchestrated by the `src/driver`.

### **2.1. Frontend (`src/frontend`)**

The frontend is responsible for parsing the source text into an intermediate representation that the rest of the compiler can understand.

* **Component**: `src/frontend/tokenizer.py`
    * **Input**: Raw MxScript source code (`.mxs` files).
    * **Process**: Performs **Lexical Analysis**. It scans the source text and converts it into a flat stream of `Token` objects (e.g., `NUMBER`, `IDENTIFIER`, `PLUS`).
    * **Output**: A list of `Token` objects.

* **Component**: `src/frontend/parser.py`, `syntax/syntax.ebnf`
    * **Input**: The stream of `Token` objects.
    * **Process**: Performs **Syntactic Analysis**. It consumes the token stream according to the grammar defined in `syntax.ebnf` and builds a hierarchical representation of the code's structure.
    * **Output**: An **Abstract Syntax Tree (AST)**, where each node represents a construct in the language (e.g., `BinaryExpr`, `FunctionDecl`).

### **2.2. Semantic Analysis (`src/semantic_analyzer`)**

This stage validates the AST for logical correctness, going beyond what syntax parsing can do.

* **Component**: `src/semantic_analyzer/analyzer.py` (example path)
    * **Input**: The raw AST from the parser.
    * **Process**:
        1.  **Symbol Table Management**: Builds and maintains scoped symbol tables to track variables, functions, and types.
        2.  **Type Checking**: Traverses the AST to verify that operations are being performed on compatible types (e.g., preventing `"hello" * "world"`). Annotates AST nodes with type information.
        3.  **ARC Analysis**: Determines where `retain` and `release` calls for Automatic Reference Counting need to be inserted.
    * **Output**: An annotated and validated AST.

### **2.3. Middle End (`src/middleend`)**

This layer acts as a bridge between the frontend and the backend, providing opportunities for high-level, target-independent optimizations.

* **Component**: `src/middleend/optimizer.py` (example path)
    * **Input**: The validated AST.
    * **Process**: (Future work) This is where optimizations like constant folding, dead code elimination, or transformations on a High-Level IR (HIR) would occur before generating LLVM IR.
    * **Output**: An optimized AST or HIR.

### **2.4. Backend (`src/backend`)**

The backend is responsible for converting the high-level AST into low-level, machine-executable code using the LLVM framework.

* **Component**: `src/backend/codegen.py`
    * **Input**: The (potentially optimized) AST.
    * **Process**: Traverses the AST using the **Visitor Pattern** (`visit_...` methods). For each AST node, it emits corresponding LLVM IR instructions. **Crucially, all calls to C++ runtime functions are generated by consulting the ABI contract.**
    * **Output**: LLVM Intermediate Representation (IR) as text.

* **Component**: `src/backend/llir.py`, `src/backend/abi_manager.py`
    * **Input**: LLVM IR text.
    * **Process**:
        1.  The `abi_manager.py` loads and provides an interface to `ffi_map.json`.
        2.  `llir.py` uses the `llvmlite` library to parse the textual LLVM IR, link it with the compiled C++ runtime (`libruntime.so`), and prepare it for execution via the LLVM JIT engine.
    * **Output**: An executable in-memory module.

---

## 3. Runtime Environment (`runtime/`)

The C++ runtime provides the essential services that MxScript programs need to execute.

* **Object Model (`runtime/include/object.h`)**:
    * `MXObject`: The base class containing `ref_count` and `const MXObjectVTable* vtable`.
    * Concrete classes (`MXInteger`, `MXString`, etc.) inherit from `MXObject`. Each has its own static vtable instance.

* **VTable Dispatch (`runtime/src/dispatch.cpp`)**:
    * Contains the top-level `extern "C"` functions (e.g., `mxs_op_add`) that are exposed to the compiler.
    * Each function's sole purpose is to look up the correct method in the object's `vtable` and call it: `return left->vtable->op_add(left, right);`.

* **Build System (`runtime/CMakeLists.txt`)**:
    * Compiles the C++ source into a shared library (`libruntime.so`) that the Python host process can dynamically load.

---
## 4. Execution and Testing

* **Driver (`main.py`, `src/driver`)**: Orchestrates the entire pipeline, passing the output of one stage to the input of the next.
* **Tests (`tests/`)**: Each component of the pipeline has corresponding unit tests to ensure its correctness and prevent regressions.
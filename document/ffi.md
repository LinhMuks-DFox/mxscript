# MxScript Foreign Function Interface (FFI) Specification

## Document Purpose

This document provides the authoritative specification for the MxScript Foreign Function Interface (FFI). All FFI-related implementation work must strictly adhere to the architecture and mechanisms described herein.

## 1\. Core Philosophy

The FFI is the sole and unified mechanism for MxScript to interface with compiled C++ code. It is used both to bind the language's standard library to its C++ runtime implementation and to allow users to call arbitrary external shared libraries.

The system is based on **Declaration Binding**. Its core principle is that any C++ function exposed to MxScript must conform to the MxScript type system. Specifically, all function arguments and return values must be of the type `MXObject*`. Interfacing with native C libraries (e.g., libc) requires a C++ wrapper that adheres to this specification. All arguments are collected into a dedicated argument vector object for dispatch.

## 2\. The `@@foreign` Annotation

### 2.1. Syntax and Placement

The `@@foreign` annotation must be placed directly before a `func` declaration.

```mxscript
@@foreign(lib: string, symbol_name: string)
func mxscript_function_name(arg1: Type1, ...) -> ReturnType;
```

### 2.2. Parameters

  * **lib: string (Mandatory):** The filename of the shared library (e.g., "runtime.so", "my\_wrappers.so").
  * **symbol\_name: string (Optional):** The exact symbol name of the C++ function to be called. If omitted, the MxScript function name is used as the default.

## 3\. Unified Dispatch Workflow

The compiler translates every FFI-bound call into a standardized sequence that invokes a universal runtime helper, `mxs_ffi_call`. There is a single, unified dispatch mode for all foreign calls.

**MxScript Declaration:**

```mxscript
# Calls a C++ function `wrapped_printf` in "my_wrappers.so".
# The "..." in the signature indicates it is variadic.
@@foreign(lib="my_wrappers.so", symbol_name="wrapped_printf")
func c_printf(format: String, ...) -> Integer;
```

**Compiler & Runtime Behavior:**
A call like `c_printf("Hello %s %d", "world", 123)` is translated by the compiler and handled by the runtime as follows:

1.  **Argument Collection:** The CodeGen gathers all arguments passed to the function (`"Hello %s %d"`, `"world"`, `123`) into a list of `MXObject*` pointers.
2.  **Argument Object Creation:** The compiler generates code to create a specialized, lightweight `MXFFICallArgv` object. This internal object wraps the list of `MXObject*` pointers.
3.  **Universal Helper Call:** The compiler generates a call to the single runtime helper `mxs_ffi_call`, passing the library name, the target symbol name, and the newly created `MXFFICallArgv` object.

**The conceptual call generated by the compiler is:**

```cpp
// 1. Arguments are prepared
std::vector<MXObject*> args = { &format_string_obj, &world_string_obj, &int_123_obj };

// 2. A specialized argument vector object is created
MXFFICallArgv* argv_obj = new MXFFICallArgv(std::move(args));

// 3. The universal helper is called
mxs_ffi_call(lib_name_obj, symbol_name_obj, argv_obj);
```

This unified approach simplifies the compiler's logic and provides a clean, efficient interface to the runtime, regardless of the number or type of arguments.

## 4\. C++ API Contract

### 4.1. The Universal FFI Helper: `mxs_ffi_call`

**Signature:**

```cpp
auto mxs_ffi_call(MXString* lib, MXString* name, MXFFICallArgv* argv) -> MXObject*;
```

**Responsibilities:**
This function encapsulates the core logic for all FFI calls and is the only FFI-related function that the CodeGen should target. Its responsibilities include:

  * Loading the specified shared library using `dlopen`.
  * Looking up the target symbol using `dlsym`.
  * Invoking the target function. To do this, it unpacks the `std::vector<MXObject*>` from the received `MXFFICallArgv` object. A robust implementation **must** use a library like `libffi` to dynamically construct the call frame for the target C++ function.
  * Returning the `MXObject*` received from the target function back to the MxScript VM.

### 4.2. The FFI Argument Vector: `MXFFICallArgv`

This is a specialized, internal-only `MXObject` subtype designed for efficient FFI argument passing.

**Conceptual Definition:**

```cpp
struct MXFFICallArgv : public MXObject {
    std::vector<MXObject*> args;
};
```

Its sole purpose is to act as a container, avoiding the overhead of the general-purpose, user-facing `MXList` object.

### 4.3. Target C++ Function Contract

**Signature:**
All C++ functions exposed via the FFI must accept `MXObject*` pointers as arguments and must return an `MXObject*`.

**Internal Type Safety:**
It is the strict responsibility of every target C++ function to perform runtime type checking on the `MXObject*` pointers it receives. It must verify the type of each argument (e.g., via `dynamic_cast` or a type field) and return an `MXError` object on a mismatch.